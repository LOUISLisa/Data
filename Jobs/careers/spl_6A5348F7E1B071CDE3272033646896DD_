{
    "SeedUrl": "https://www.spl.yt/intern-business-development",
    "OutLinks": [
        "https://www.spl.yt/",
        "https://www.spl.yt/blockchain",
        "https://www.spl.yt/careers",
        "https://www.spl.yt/devs",
        "https://www.spl.yt/learn-more"
    ],
    "ContentType": "text/html",
    "Parent": "https://www.spl.yt/intern-business-development",
    "RequiredMatch": "decentralized",
    "DocumentType": "Careers",
    "Title": "spl.yt \u2013 decentralized e-commerce",
    "Hash": "6A5348F7E1B071CDE3272033646896DD",
    "Url": "https://www.spl.yt/devs",
    "CrawledDate": "2020-07-28",
    "DomainId": "spl",
    "TackIt": "true",
    "Body": "Home Blockchain Learn More Devs Blog Careers See Now SPLYT DEVS v 0.4 Connections To The Spl.yt Protocol Setting up your Geth Server Backend Server Architecture Connecting to Ethereum Ethereum.js Library Responding to Ethereum events to update your database Client side market place Things needed from an user of a marketplace Spl.yt Global Inventory Create a Listing How to own/fractionally own a listing Starting a new project? contact us at hello@spl.yt View on Github Welcome to Spl.yt! We will be continuously adding documentation to the Spl.yt Core code library to make it easy to connect to the blockchain and the spl.yt protocol. Setting up your Geth Server Downloading geth client: Download ethereum client (geth) from here. Extract it to a desired location. Open terminal and cd to the folder where geth is located. Creating a wallet: Then type ./geth --testnet account new in the terminal to create a new testnet wallet. Geth client will prompt you to enter password twice to create a wallet. Downloading public testnet: Type in terminal ./geth --testnet --verbosity 1 console . This will sync the Ropsten testnet to your computer. Current block # for Ropsten is # 3,077,160 at the time of writing. So sit back and wait until your node downloads all the blocks up till the current block. You can check the sync status buy typing in geth console web3.eth.syncing which will display block information. Get your wallet address by typing web3.eth.accounts[0] We'll get some fake ether from here. You'll need to give them your wallet address. Get solidity compiler using sudo npm install -g solc (Installing npm is outside of this tutorial's scope). CD to the compiler installation directory. Usually its in ~/.npm-packages/lib/node_modules/solc Lets compile our contract by typing: ./solcjs --abi --bin -o Full-path-to-output-folder Full-path-to-input-contract-file This will generate a folder in the Full-path-to-output-folder that contains binary conversion and ABI of the contract. Binary file is what we insert to blockchain. ABI (Application Binary Interface) is what we use to access the contract on blockchain. Rename the files Contractname.bin and Contractname.abi respectively. By now you should have fake ether sent to your wallet. Check it by sending this command in geth terminal. web3.eth.getBalance(web3.eth.accounts[0]) . If it says zero. Then you haven't recieved ether. try step 10 again. Backend Server Architecture Today we use a traditional client-server architecture for our Splyt demo. It consists of a Geth server, and a RESTful API written in Node.JS using Express, and MongoDB to . The marketplace websites use a PHP backend to communicate with the API, and normal front-end technologies on the client side. Be sure not to expose your Geth server to the internet. Consider keeping it within your own network and allow only connections from authorized hosts, like your API server. Configuration Platform: node Framework: express Database: mongodb Connecting to Ethereum In ethereum.js you'll find the functions to interact with Ethereum using Splyt's smart contracts. It expects an environment variable of ETHEREUM_URI, which is the URI to Geth server. It should be something like http://127.0.0.1:8585 depending on your network and Geth configuration. Ethereum.js Library We use the Web3 package to communicate with our Geth server. https://github.com/ethereum/web3.js/ Our ethereum.js module wraps those interactions, so you shouldn't need to use web3 directly for Splyt transactions. Just be sure to set the ETHEREUM_URI environment variable mentioned earlier. Responding to Ethereum events to update your database Since blockchain doesn't have a way to search for a listing or its properties, each market place will be listening to events broadcasted from splytTracker contract so that any marketplace who's listening to the events can recieve metadata of a listing. Then marketplaces developers can save it in their own database for faster searching and indexing. To listen to newly created listing events use this snippet of code: var listingCreation = web3.eth.subscribe('logs', {\n    address: '0x123456..',  // splytTracker contract address\n}, function(error, result){\n    if (!error)\n        console.log(result); // this will tell you the contract address of newly created listing\n});\n\n// unsubscribes the event listingCreation event\nsubscription.unsubscribe(function(error, success){\n    if(success)\n        console.log('Successfully unsubscribed!');\n});\n Do the same for a contribution event: When a user contributes to a listing, thus closing the listing. Once you capture the event, you can go ahead and call the function ethereum.getAssetConfig(assetAddress). This will give you all the metadata of a given listing. Store the metadata in a database so that users can search and filter all the listings, to make them interact easier. *More events will be added as we progress into the project. Client side market place To consider making a trustless marketplace, a developer could create a desktop app (using electron, native or any flavor of other frameworks). This eliminates the need to trust a marketplace with users's data. 2 ways to go about: 1. Create a truly client side system: Creating an app where the marketplace connects directly to users's blockchain node. Essentially you will be using the same ethereum.js file to connect to localhost:8545 blockchain node. Rest will be similar to other setups. **Some caveats are that your users might not want to download Gigabytes of blockchain data just to use a marketplace. Continue reading to solve this issue. 2. Create a hybrid-clientside system: Creating an app where the clientside marketplace connects to a marketplace hosted blockchain node. This alleviates the need for each users of your marketplace to download blockchain data for no added benefits. In this model, marketplace developer will create a clientside application which will connect to their hosted blockchain node. There's less users's trust but its more convenient for them. Things needed from an user of a marketplace Marketplace developers should be aware that users are holding tokens in their personal wallets, thus managing tokens for them if not possible. Developers will need to sign transactions using users's wallets. Managing users's wallets on behalf is dangerous and also not recommended. Users who want to interact with splyt will require SAT tokens as well as some amount of Ether (to pay for transaction cost) in their wallets. *There is a way to use SAT tokens to pay for gas which isn't implemented yet, at the moment. Create a Listing Ethereum transactions do not resolve immediately, which requires a different mindset in making your application. When a user creates a listing, it may take a great deal of time for that transaction to be entirely processed, and could fail for any number of reasons. Obviously, you won't want to wait that long to give a response to your user. The recommended approach is to create a unique identifier, and store a correlation record in your own database with that identifier. You'll listen for the resolution of that listing event, and then updating your record accordingly with the Ethereum result. The ethereum.deployContracts function submits your listing to Ethereum. It expects two parameters, information about the asset in the listing, and information about the listing itself, including the marketplace. Currently, nothing is returned as it is expected that your application will listen for the eventual completion of this event, explained later in this document. Anticipate breaking changes as we iterate on, and improve the API. It is likely to be changed and simplified. \nconst ethereum = require(\"./controllers/ethereum.js\");\n\nconst uuidv4 = require(\"uuid/v4\"); // https://www.npmjs.com/package/uuid\n\n// The date this listing should expire, such as in thirty days\nconst expirationDate = new Date();\nexpirationDate.setDate(expirationDate.getDate() + 30);\n\nconst asset = {\n  // Your unique correlation ID for this asset\n  id: uuidv4().toString(),\n  // The string ID of the terms for ownership of this asset.\n  // Right now we only support DAYS, but will be expanding this to other\n  // terms as the product grows.\n  termType: \"DAYS\",\n  // The title or short description of the asset\n  title: \"Contemporary Art\",\n  // The integer amount of SATs for all costs for this asset\n  totalCost: 32168\n};\nconst marketplace = {\n  // The wallet address of the marketplace creating this listing\n  walletAddress: process.env.MARKETPLACE_WALLET_ADDRESS,\n  // The integer percent of the final amount that will be given to the marketplace which completes the sale of this listing\n  kickbackAmount: 5\n};\nethereum.deployContracts(asset, {\n  expirationDate,\n  marketplace\n}); How to own/fractionally own a listing For non-fractional listings one must contribute the full amount of SATs for the asset. For fractional assets, partial amounts are acceptable. Anticipate breaking changes as we iterate on, and improve the API. It is likely to be changed and simplified. const ethereum = require(\"./controllers/ethereum.js\");\n\nconst contribution = {\n  // The amount of SATs the user is attempting to contribute\n  amount: 4000,\n  // The address of the contributor's wallet\n  userWalletAddress: \"0x...\",\n  asset: {\n    // Whether this asset is fractionally owned (coming soon!)\n    isFractional: false,\n    // Your correlation ID for this asset, generated when the listing was created\n    id: \"f9acaf3d-276a...\"\n  },\n  // The address of the user selling this asset\n  listing: { listedByWalletAddress: \"0x...\" }\n};\nethereum.contribute(contribution); A Promise is returned from this function. If there is an immediately-detectable error, it will contain that information. Otherwise, it is resolved successfully, and your application will listen for the eventual completion of this event, explained later in this document. License The MIT License (MIT) Copyright (c) 2019 Splyt Core Foundation Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
}